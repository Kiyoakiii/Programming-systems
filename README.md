# КУРСОВОЙ ПРОЕКТ

По дисциплине «Системы программирования»

На тему: «Проверить является ли АТ-грамматика L-атрибутивной»

#### Определение. 

АТ-грамматика называется L-атрибутной тогда и только тогда, когда выполняются следующие условия: 
1. Аргументами правила вычисления значения унаследованного атрибута символа из правой части правила вывода могут быть только унаследованные атрибуты символа из левой части и произвольные атрибуты символов из правой части, расположенные левее рассматриваемого символа. 
2. Аргументами правила вычисления значения синтезированного атрибута символа из левой части правила вывода являются унаследованные атрибуты этого символа или произвольные атрибуты символов из правой части. 
3. Аргументами правила вычисления значения синтезированного атрибута операционного символа могут быть только унаследованные атрибуты этого символа.

В рамках описания алгоритма псевдокодом будем считать, что ```p``` - синтезированный ```р, r``` - унаследованный ```r```;

```f(Xaj.p).att : Xa1.p,Xa2.p,...,Xak.p``` - аргументы правила вычисления 
синтезированного значения атрибута ```Xaj.p```;

```f(Xaj.r).att : Xa1.p,Xa2.p,...,Xak.p``` - аргументы правила вычисления унаследованного значения атрибута Xaj.r;

```Xaj.attribute``` - атрибут символа ```Xaj ```;

```{Xa1...j-1}``` - множество символов ```Xak :  k= 1, 2, ..., j-1```;

```{f(Xa1)}``` - множество правил вычислений атрибута символа Xa1;

Алгоритм (псевдокод):
```
foreach  (Ap→Xa1,...,Xan)      // для всех правил грамматики 
    foreach  (Xaj{X})  // для каждого символа, справа
        if (Xaj.attribute  = r)	
            if !(f(Xaj.r ).att  {Xa1...j-1 Ap.r}) 
                return FALSE

        j++
        if (Ap.p)	
            if !(f(Ap.p).att  {Xa1...n Ap.r} )
        	     return FALSE

        if (Xaj = OP   and   Xaj.attribute  = p) 
            if !(f(Xaj.p).att  {Xaj .r}) 
        	     return FALSE 
      
    end foreach
    p++
end foreach
return TRUE	
```
Пример анализа АТ-грамматики:

АТ-грамматика описывает перевод оператора присваивания некоторого языка программирования в цепочку тетрад с кодами операций: сложения, умножение, присвоить. Левой частью оператора присваивания является идентификатор, а правой частью - бесскобочное арифметическое выражение, выполняемое слева направо в порядке написания операций. 

Входные символы: ```{i, +, *, =}, i``` - лексема, представляющая идентификатор.
Операционные символы: ```{+}, {*}``` - имеют по 3 унаследованных атрибута, ```{=}``` -  имеет 2 унаследованных атрибута 
Нетерминалы: ```S, E, R. S``` - начальный символ (без атрибутов), ```E``` -  один синтезированный атрибут, ```R``` - один унаследованный, один синтезированный.

```Syn = { a1, b3, b4 }```

```Inh = { b1, b2, c1, d1, d2, e1, e2, e3, f1, f2, f3 }```

Также для упрощения просмотра вывода было принято решение сделать цветными атрибуты: ```Syn``` - зеленый, ```Inh``` - фиолетовый цвет.

```Ea1```  синтезированный ```a1```

```Rb1, b3```  унаследованный ```b1```, синтезированный ```b3```

```ic1``` унаследованный ```с1```

У операционных символов все атрибуты унаследованы.
```
{:=}d1, d2   	d2 ← d1
{+}e1, e2, e3  	e3 ← e1 + e2
{*}f1, f2, f3   	f3 ← f1 * f2
```
 Правила:
 ```
1: 	S → ic1  := Ea1  {:=}d1, d2  
d1 ← c1
d2 ← a1

2: 	Ea2 → ic1  Rb1, b3
b4 ← c1
a1 ← b2

3:	Rb1, b3  → + ic1  {+}e1, e2, e3 Rb2, b4
b4, e3 ← GETNEW
e1 ← b3
e2 ← c1
b1 ← b2

4:	Rp1, t2 → * ic1   {*}f1, f2, f3 Rb2, b4
b4, f3 ← GETNEW
f1 ← b3
f2 ← c1
b1 ← b2

5:	Rb1, b3  → 
d1 ← b3
```
Процедура-функция ```GETNEW``` выдает значение указателя на свободную позицию в таблице, в этой позиции будут храниться промежуточные результаты. Для выполнение этой задачи было сделано:
1. Добавлены новые функции, которые позволяют красить атрибуты в соответствии с тем какому классу они принадлежат.
2. Реализован вывод ```Symbol_Operation``` вместе с их атрибутами, а также вывод ```Operation_Symbols_Rules```.
3. Алгоритм проверки AT-грамматики на L-атрибутивность.
   
Благодаря выполнению пунктов 1 и 2 пункт 3 было выполнить не очень сложно.

Запустим программу и посмотрим, что выводит:

```
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Давайте проверим вашу AT-грамматику на L-атрибутивность:


AT-Grammar G = (V, T, OP, P, S)
Syn = { a1, b3, b4, b5, e4, e5 },
Inh = { b1, b2, c1, d1, d2, e1, e2, e3, f1, f2, f3 },
V = { S, E.a1, R.b1.b3 },
T = { *, +, i.c1 },
OP = { {:=}.d1.d2, {+}.e1.e2.e3, {*}.f1.f2.f3 },
S = S

Operation Symbols Rules:
{:=}.d1.d2:    d2 <- d1
{+}.e1.e2.e3:    e3 <- e1 + e2
{*}.f1.f2.f3:    f3 <- f1 * f2

Grammar Rules:

1:    S -> i.c1:=E.a1{:=}.d1.d2
      d1 <- c1
      d2 <- a1

2:    E.a1 -> i.c1R.b1.b3
      b1 <- c1
      a1 <- b3

3:    R.b1.b3 -> +i.c1{+}.e1.e2.e3R.b2.b4
      b4, e3 <- GETNEW
      e1 <- b3
      e2 <- c1
      c1 <- b4
      c1 <- b3
      b3 <- b5
      b3 <- b1
      e4 <- e5
      b1 <- b2

4:    R.b1.b3 -> *i.c1{*}.f1.f2.f3R.b2.b4
      b4, f3 <- GETNEW
      f1 <- b3
      f2 <- c1
      b1 <- b2

5:    R.b1.b3 -> e
      d1 <- b3


-------------------:
Проверим L-атрибутивность АТ-грамматики

для 1-го правила вывода
d1 <- c1
d2 <- a1
для 2-го правила вывода
b1 <- c1
a1 <- b3
для 3-го правила вывода
b4, e3 <- GETNEW
e1 <- b3
e2 <- c1
c1 <- b4
НЕ L-атрибутивна(нарушение 1-го условия), так как в правиле для 1-го символа присутствует атрибут правее: b4
c1 <- b3
НЕ L-атрибутивна(нарушение 1-го условия), так как в правиле для c1 синтезированного атрибута символа присутствует синтезированный атрибут символа слева: b3
b3 <- b5
НЕ L-атрибутивна(нарушение 2-го условия), так как справа нет такого атрибута: b5

b3 <- b1
e4 <- e5
НЕ L-атрибутивна(нарушение 3-го условия), так как синтезированный атрибут унаследует синтезированный атрибут этого же OP символа: e5
b1 <- b2
для 4-го правила вывода
b4, f3 <- GETNEW
f1 <- b3
f2 <- c1
b1 <- b2
для 5-го правила вывода
d1 <- b3

ATGrammar is not L-attributive.


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
```
